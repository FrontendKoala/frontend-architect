# 字节 编码 总结
1. 内存大小的关系 bit  >>  byte >> k >> mb >> g >> t  从小到大  8个bit位 === 1字节   1024字节===1k .... 1024mb === 1g，所以通常所说的内存大小为字节的大小，而非bit，因为最小单位是按1个字节计算的
2. 字符、字节、编码的关系   1个字符可能有多个字节，字节的大小取决于编码方式。
  1. 不同的编码方式，1个字符所代表的字节数不同。utf-8中汉字为三个字节，gbk中汉字为2个字节。
  2. ascii编码表中出现的字符均为一个字节，因为ascii表的最大编码数为127，一个字节为8个bit位，最大可以表示255个数，因此asscii表中的字符，在常规编码中，都为一个字节。

# buffer1
1. 前端传递给后端的文件都是二进制对象，后端需要将二进制转成字符串(很早以前js中只有string、number这些数据类型，为了在js能有表示二进制数据的类型，因此产生了buffer)
- 扩充： 浏览器的Blob、File为二进制对象
2. Buffer是一个二进制对象，用于存储二进制数据。
3. Buffer可以将二进制和字符串进行方便的转化

# 进制的转换0
1. 进制为存储数据的一种形式。
2. 进制的最小单位是二进制。
3. 二进制、十进制、8进制、16进制之间可以互相转化，只是换一种表达二进制的方式而已。

# 字节和位
1. 一个字节有八个二进制位，1字节(b) = 8比特(bit)
2. 八个位相当于八个坑，每个位上存储的是0或1，是一个二进制数据
3. 一个字符有几个字节取决于编码方式，如utf-8 gbk等编码方式，不同环境下的编码方式是不同的

# 进制的转换1：将一个字节的二进制转成十进制
0. 通过1\*2的n次方累加的和即为十进制(n代表1后面有多少位)。比如 1 0000 0001  转为十进制  1 * 2*\*8 + 1 * 2*\*0 = 257
1. 一个字节的最大值是8个1，[1 1 1 1 1 1 1 1]。 2*\*0 + 2*\*1 + 2*\*2 + .... + 2*\*7  
```
var sum =0
for(var i = 0; i<8;i++){
    sum += 1 * Math.pow(2, i);
}
console.log(sum);
也就是说一个字节代表的十进制的值最大是255
```
2. 计算[0000 1001] 则为 1 * 2*\*0 + 1 * 2*\*3

# 编码
1. 编码代表的是一种规范，用于规定一个字符(字母、符号、汉字)所占用的字节个数。

# ASCII码
1. ascii码是一种对字符的编码规范，规定了英文字母及特殊符号对应的十进制数
2. 最大的ascii码为127，意味着一个字母或特殊符号占用一个字节即可进行表达
3. ASCII码对应的字符都是字符串，不会有数据类型一说。码是将字符串编码编码后得到的二进制数(ascii表中通常用十进制表示)

# GBK编码
1. 是针对国标字体的编码，一个汉字为两个字节、一个字母为1个字节。通过255*255来六万多个汉字

# UNICODE编码
1. 为全球字体通用编码，但没发展起来

# UTF-8编码
1. 全球通用编码规范，对UNICODE进行了转义，规定了一个汉字占用3个字节，字母和符号占用1个字节，是一种字节长度可变的编码规范。

# node中的编码
1. node中只支持utf-8编码，不支持gbk编码，其中字母和符号遵循最早的ASCII编码，占用一个字节，汉字占用三个字节
2. node中内存的最小单位为字节

# 进制的转换2
1. (不重要可忽略)一个字节的最大二进制数 转为十进制的快速计算方式为 1 * 2\*\*8 - 1。由于八个二进制的1再加1等于1 0000 0000 ，因此通过2\*\*8可以快速得到次数
2. 数值中以0b开头表示二进制，0b11 等于 3。以0x开头代表十六进制，0xf代表15 0x10代表16。以0或0o开头代表八进制。
3. 手动将十进制转成任意进制的方式为，十进制数/进制不停的取余，直到取尽为止，最后一个的商和其余的余数倒着拼接则为对应进制的数。
``` js
将389转成16进制 
389 / 16 >> 24 余5 
24 / 16 >> 1   余8
最后结果185
```

``` js
将142转成14进制 
142 / 14 >> 8 余14 
14大于9，从10开始以a计算，14为e，因此为8e
最后结果185
```
4. 将任意进制数转为十进制数的方法，parseInt('x', y); y代表的是进制，如8进制、16进制，x为进制对应的数(需要为字符串)。返回值为对应的十进制数。如parseInt('ff', 16)返回值为255。
5. (重要)将任意进制转为任意进制的方法，x.toString(y)  x为任意进制数，y为要转成的进制(默认不填代表十进制)，返回值为转换后的结果。如
```
console.log((02).toString(2)) // 10  将八进制的2转为2进制
console.log((0x16).toString()) // 22  将十六进制转为十进制
console.log((0b11).toString()) // 3  将2进制转成十进制
```

# 位运算符 << | &
0. 位运算 >> << 是对二进制数进行计算，如果不是二进制数会自动转成二进制再进行计算。
1. <<代表二进制数整体向左移动，移动几位增加几个0。>>代表整体向右移动，移动几位去除几位。
```
0b1 << 1 结果为 0b10   // 左移 快速计算方式，移动了n位，在原来数的基础上 乘以 2的n次方即可
ob11 >> 1 结果为 0b1
```
2. 或 | 与 & 运算
```
(0b110 | 0b010).toString(2)  //110  计算后默认为十进制，需要通过toString转为2进制查看结果
(0b110 & 0b010).toString(2)  //010  
```

# base64编码
1. base64编码原理，以下为一个汉字的编码规则，不同的字节个数base64的编码规则不同。
```
// 转成用16进制标识的三个字节
console.log(Buffer.from('珠'))  // <Buffer e7 8f a0>

// 将16进制转成二进制
console.log((0xe7).toString(2)); // 11100111
console.log((0x8f).toString(2)); // 10001111
console.log((0xa0).toString(2)); // 10100000

// 将转换后的二进制重新组合 按6位进行拆分
// 111001 111000 111110 100000

// 将每一组二进制数补成一个字节
// 00111001 00111000 00111110 00100000

// 将二进制转成十进制
console.log(parseInt('00111001', 2)); // 57
console.log(parseInt('00111000', 2)); // 56 
console.log(parseInt('00111110', 2)); // 62
console.log(parseInt('00100000', 2)); // 32

// 64位字符
let str = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' // 26个
str += str.toLowerCase()
str += '0123456789+/'

console.log(str[57] + str[56] + str[62] + str[32]);
```
2. 将一个字符转成base64的方法 Buffer.from('a').toString('base64')
3. 可以通过base64对所有的图片进行编码，但编码后会变大1/3，所以图片过大的话不适合用base64再进行编码

# buffer2
1. buffer是用十六进制的数表示字节
2. buffer的大小不可被改变，也就是说buffer的长度不可以改变，里面的值可以改变。
3. Buffer.alloc() 用于申请一个固定长度的内存存放字节
```
const  buffer = Buffer.alloc(10); // 申请长度为10个字节的内存
console.log(buffer); // <Buffer 00 00 00 00 00 00 00 00 00 00>
```
4. (非重要)Buffer.from([1, 2, 3]); // 1 2 3为十进制的二进制数值，而非普通的数字，转成buffer后会转成对应的十六进制
5. Buffer.from('1'); // 将一个字符串转成对应的字节
```
const buf1 = Buffer.from('1');
console.log(buf1) // <Buffer 31>

const buf2 = Buffer.from('珠');
console.log(buf2) // <Buffer e7 8f a0>
```
6. Buffer.from('珠').toString('base64') // 54+g  对字符串进行base64编码

# node处理gbk编码的文件内容
``` js
const fs = require('fs')
const path = require('path')
const iconv = require('iconv-lite') // 第三方模块，需安装
fs.readFile(path.resolve(__dirname, 'a.txt'), function(err, data){ // 第二个参数不写utf-8，则data为buffer。
  console.log(iconv.decode((data), 'gbk')); // iconv可以将二进制的buffer进行gbk解码
})
```