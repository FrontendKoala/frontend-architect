# fs.writeFile  
第二个参数为写入的数据，只能是字符串或buffer

# fs.readFile 
加utf-8读出来的是字符串，如果没有加读出来的是buffer

# fs.open fs.read fs.write fs.close
- todo: 通过递归分片读写文件
```
const fs = require('fs')
const path = require('path')

const alloc = Buffer.alloc(3);
fs.open(path.resolve(__dirname, 'a.txt'), 'r', (err, fd) => {
    fs.read(fd, alloc, 0, 3, 0, (err, bytesRead, buffer) => {
        fs.open(path.resolve(__dirname, 'c.txt'), 'w', (err, wfd) => {
            fs.write(wfd, buffer, 0, 1, 0, (err, written) => {
                fs.close(fd, () => {})
                fs.close(wfd, () => {})
            })
        })
    })
})
```

# fs.createReadStream
```
const fs = require('fs')
const path = require('path')

const res = fs.createReadStream(path.resolve(__dirname, 'a.txt'), {
    flags: 'r',
    autoClose: true,
    highWaterMark: 3, // 分片读取  官方推荐分片大小为64k比较合适
    start: 0,
    end: 11,
})

res.on('open', function(fd) {
    console.log(fd);
});

const bufferArr = []

res.on('data', function(data) {
    bufferArr.push(data)
})

res.on('end', function() {
    console.log(Buffer.concat(bufferArr).toString()); 
})

res.on('close', function(){
    console.log('close');
})
```

# fs.createWriteStream
```
const res = fs.createReadStream(path.resolve(__dirname, 'a.txt'), {
    flags: 'r',
    autoClose: true,
    highWaterMark: 3,
    start: 0,
    end: 11,
})

const rw = fs.createWriteStream(path.resolve(__dirname, 'b.txt'), {
    flags: 'w',
    emitClose: true,
    start: 0,
    highWaterMark: 1
})

res.on('data', function(data) {
    rw.write(data, 'utf-8', (err) => {
        err && console.log(err);
    })
})
```