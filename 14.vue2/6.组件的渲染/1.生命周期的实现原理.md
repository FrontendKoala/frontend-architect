# Vue声明周期的用法
``` js
Vue.mixin({
    beforeCreate() {
        console.log(111)
    }
})

Vue.mixin({
    beforeCreate() {
        console.log(222)
    }
})

const vue = new Vue({
    el: '#app',
    beforeCreate() {
        console.log(333)
    }
})

console.log(vue.a);
// 运行结果  111 222 333
```

# 生命周期的实现原理
1. 实现原理核心使用的是发布订阅，把Vue.mixin({})和vue实例中options中的生命周期方法按照相同的名字依次存放到一个数组中，到达某个阶段后按照添加顺序依次执行生命周期的方法，优先执行mixin中的方法。
2. 具体实现步骤如下：
   1. 将每个Vue.mixin的options合并到Vue.options中
      1. 在Vue的类上面定义一个options对象，用于存放Vue.mixin的全局配置。
      2. 通过遍历Vue.options和Vue.mixin上的属性值，将Vue.mixin的options合并到Vue.options上。合并时：对于生命周期函数采用了策略模式，当合并的的options属性名命中策略时，通过运行对应的策略返回新的生命周期函数数组交给Vue.options。没有为命中策略：如果是对象则使用展开运算符...进行合并。如果是其他类型则直接覆盖(如果Vue.mixin的options属性值为undefine，则继续使用Vue.options上的值)。
   2. 将Vue.options合并到组件自己的$options上。
      1. 每个组件初始化的时候都会将自己的options和Vue.options的配置进行合并。如果vm上定义了生命周期函数，会将vm的生命周期函数concat到Vue.options中。因此可以做到执行生命周期函数时，是先执行Vue.mixin中定义的函数。
      2. 这里的Vue.options需要使用this.constructor.options，这样做是为了让子组件的constructor脱离大Vue。
   3. 执行生命期函数
      1. 定义callHook函数，参数为vm和生命周期函数名，通过vm.$options和函数名取到对应的函数数组，遍历函数数组，依次call函数，this执行vm。
      2. 执行顺序如下：mergeOptions(合并所有的options) => callHook(beforeCreate) => initState(数据劫持、收集自定义watch) => callHook(created) => compileToFunction(模板编译、生成render函数) => callHook(beforeMount) => new Watcher(回调updateComponent更新视图、收集渲染watcher和computed watcher) => callHook(mounted) 
   