# diff算法目的
1. 操作dom很浪费性能，dom diff可以减少对dom的操作

# dom diff 发生的阶段
1. 当data的数据被修改后，会触发渲染watcher回调updateComponent。
2. updateComponent会触发patch方法，将老的vNode ?? 和 新的vNode ?? 传入patch进行对比更新并更新真实dom。

# vNode diff的过程
1. 比较方式：
   1. 树形结构的平级比较。每一层和每一层对比。
   2. 没有进行跨层比较的原因是一般用户很少会通过数据的变化修改dom的结构。如果跨层比较的话会将计算量按指数级增长，所以没必要做这样的比较。

2. 如果新老节点的 tag不同
    - 直接用新vNode创建dom替换掉老vNode对应的dom。

3. 如果新老节点的tag相同，则将老节点的el赋值给新节点的el，这样新节点即挂载了el属性。
   - 以下提到的更新老节点，指的都是更新老节点的el，也就是页面上的真实dom。

4. 如果新节点是文本
    - 如果新老节点的text不相同，则直接使用新节点text替换掉老节点text。

5. 如果是非文本节点
    1. 对比属性
        - 删除新节点没有的属性：遍历老节点的属性，如果发现新节点没有该属性，则删除该属性。
        - 增加及更新新节点属性：遍历新节点的属性，将新节点的属性覆盖掉老节点的el属性即可。
        - 更新style属性：遍历老的style，删除新style没有的属性。遍历新的style，覆盖掉老的style属性。
    2. 对比老节点的儿子们和新节点的儿子们
        1. 整体思路：
           - 通过while循环+双指针的方式，同时遍历老儿子们和新儿子们进行对比。每比对完一次，移动一下头指针或者尾指针。只要有任意一方的儿子们指针相遇，则结束循环。然后通过for循环继续遍历while循环没处理完的新老儿子。while + 双指针的具体逻辑如下：
        2. 初始化：
           - 首先定义好新老节点的头指针和尾指针。newStartIdx、newEndIdx、oldStartIdx、oldEndIdx。初始化时，将头指针和尾指针分别指向新老儿子的头部和尾部。
           - 定义isSameNode方法，如果tag和key都相同，则为同一个节点。
        3. 头头相比：
           - 将新儿子和老儿子的头部节点进行比较，如果相同，使用新儿子更新老儿子，递归走上面的第三步逻辑。同时将新老儿子的头指针向后移动一位。
           - 如果不同则进行尾尾相比。
        4. 尾尾相比：
           - 将新老儿子的尾部节点进行比较，如果相同，使用新儿子更新老儿子。将新老儿子的尾部指针向前移动一位。
           - 如果不同则进行头尾比较。
        5. 头尾相比：
           - 将老儿子的头部节点和新儿子的尾部节点进行比较，如果相同，则使用新儿子的尾部节点更新老儿子的头部节点。同时把老儿子的el插入到当前尾结点的后面。然后将老儿子的头指针向后移动一位。将新儿子的尾指针向前移动一位。
           - 如果不同则进行尾头比较。
        6. 尾头相比：
           - 将老儿子的尾部节点和新儿子的头部节点进行比较，如果相同，使用老儿子的尾部节点更新掉新儿子的头部节点。同时把老儿子的el插入到当前头节点的前面。将老儿子的尾指针向前移动一位。将新儿子的头指针向后移动一位。
           - 如果不同则进行乱序对比。
        7. 乱序相比：
           - 前面四种都没找到相同节点，则将新节点和老节点挨个进行比较，没找到则给新节点创建新元素，并将其el放到当前老头节点el的前面。如果找到则使用新节点更新节点，然后将老节点的el移到当前头节点的前面，同时给老节点添加已比较的标识？？？？？？？。最后将新节点的头指针向后移动。
           - 乱序比较特殊的一点：当老儿子没有被匹配到，老儿子的指针不会移动。
        8. 遍历while没处理完的新儿子：
           - 如果有没处理完的新儿子，一定是向后添加。因为在while循环里发现有新儿子，但没老儿子，已经将新儿子插入到前面去了。
           - 向后添加时，要插入到当前最后一个元素的后面。
        9.  遍历while没处理完的老儿子：
           - 将没有遍历完的老儿子删除即可。没有遍历完则代表新儿子里没有这些节点。
6. 操作dom时，由于没有insertAfter api。所有向后添加元素，均使用insertBefore代替。
``` js
// 假设a和b是兄弟节点，parent是父节点
// 要往a后面插入c元素，在获取到a但没有获取到b的情况下，可以使用：
parent.insertBefore( c, a.nextSibling ) // a.nextSibling代表的是b
// 如果第二个参数为null则相当于appendChild，在尾部添加的意思。
```