# 更新渲染，响应式原理
1. 首次渲染：在构建render方法时，会触发到每个属性的get方法。在get方法中给每个属性绑定dep和watcher。
    1. 在mountComponent时创建渲染Wather的实例。new Watcher实例时，会通过watcher的get>>getter>>updateComponent>>update(render)完成页面的渲染
    2. 给每个属性绑定dep及watcher：通过ast生成render方法时，会获取模板用到的data属性的get方法。在get时，会new一个Dep实例，调用dep.depend()，将dep添加到watcher的deps上。同时将watcher添加到dep的subs(watchers)中。dep和watcher实例都有自己的全局唯一id，在多对多绑定时，会保证唯一性。
    3. 在执行watcher里的get时，生成虚拟dom(执行update(render))前，会先在Dep.target上设置当前渲染watcher的实例，当页面渲染完毕后，再删除Dep.target上watcher。这样就锁定了render执行过程中，触发data的get时，dep所要绑定的watcher。

2. 更新渲染：当data属性的值发生变化时，会调用dep的notify方法，触发dep的渲染watcher进行页面渲染。
    1. 为了减少多个属性改变时，会导致页面多次渲染，在调用watcher更新时，会利用同步和异步的机制，让第一个赋值操作同步执行完后，异步执行watcher的get，这样可以先等赋值操作全部同步执行完后，异步执行watcher的get方法，get方法调用render重新渲染页面。(dep.notify => watcher.update => scheduler.queueWatcher => nextTick => wather.run => watcher.get)
    2. 异步更新：vue2中封装了自己的nextTick方法，nextTick内部缓存了nextTick的cb，通过timer异步清空nextTick中的cb。(这样用户和vue2内部都可以调用nextTick方法，当用户调用时，内部的已排在前面，这样可以确保用户调用nextTick时，页面已更新完毕)。
    3. vue2中timer的封装优先级：Promise => MutationObserver => setImmediate => setTimeout,vue3中只使用了promise

3. 对data中的[]或{}的属性值依赖收集的处理
    1. 如果data的属性值是{}，由于根据ast创建render方法时，对text使用了JSON.stringfy，因此模板中直接使用对象，会触发到对象每个属性的get。因此可以对{}每个属性进行依赖收集。
    2. 如果data的属性值是[]，在数据劫持阶段是把数组本身和它里面的对象或数组进行隔离依赖收集。在对数组进行observer时，会给数组定义__ob__属性，value为Observer的实例，Observer的实例上挂载了一个新的dep实例。这样在操作数组api时，可以通过数组的__ob__触发关联的watcher。对于数组里面的每一项如果是数组的话，递归走observer，如果是非数组，则走defineProperty。当通过data获取数组时，会将数组对应的__ob__.dep和当前的wather进行关联。这样操作数组的api时，就可以通过数组的__ob__找到对应的watcher进行页面渲染。
    3. 数组依赖收集二次整理：
        数组劫持阶段：在new Observer的时候创建一个__ob__、一个dep，通过__ob__将dep和数组关联起来
        依赖收集阶段：如果发现value的__ob__有值，将value的__ob__.dep和当前Dep.target的wather进行绑定
        异步更新阶段：当操作数组时，会根据数组的__ob__关联触发对应的wather进行渲染