# 更新渲染，响应式原理
1. 首次渲染：在构建render方法时，会触发到每个属性的get方法。在get方法中给每个属性绑定dep和watcher。
    1. 在mountComponent时创建渲染Wather的实例。new Watcher实例时，会通过watcher的get>>getter>>updateComponent>>update(render)完成页面的渲染
    2. 给每个属性绑定dep及watcher：通过ast生成render方法时，会获取模板用到的data属性的get方法。在get时，会new一个Dep实例，调用dep.depend()，将dep添加到watcher的deps上。同时将watcher添加到dep的subs(watchers)中。dep和watcher实例都有自己的全局唯一id，在多对多绑定时，会保证唯一性。
    3. 在执行watcher里的get时，生成虚拟dom(执行update(render))前，会先在Dep.target上设置当前渲染watcher的实例，当页面渲染完毕后，再删除Dep.target上watcher。这样就锁定了render执行过程中，触发data的get时，dep所要绑定的watcher。

2. 更新渲染：当data属性的值发生变化时，会调用dep的notify方法，触发dep的渲染watcher进行页面渲染。
    1. 为了减少多个属性改变时，会导致页面多次渲染，在调用watcher更新时，会利用同步和异步的机制，让第一个赋值操作同步执行完后，异步执行watcher的get，这样可以先等赋值操作全部同步执行完后，异步执行watcher的get方法，get方法调用render重新渲染页面。(dep.notify => watcher.update => scheduler.queueWatcher => nextTick => wather.run => watcher.get)
    2. 异步更新：vue2中封装了自己的nextTick方法，nextTick内部缓存了nextTick的cb，通过timer异步清空nextTick中的cb。(这样用户和vue2内部都可以调用nextTick方法，当用户调用时，内部的已排在前面，这样可以确保用户调用nextTick时，页面已更新完毕)。
    3. vue2中timer的封装优先级：Promise => MutationObserver => setImmediate => setTimeout,vue3中只使用了promise

3. 响应式原理面试话术：
    响应式原理核心是通过definePrototype对data属性get和set方法的拦截，实现数据更新后自动渲染页面的目的。
    主要实现步骤分为以下三个步骤：
    1. 数据劫持
       1. 在初始化时会通过initState、initComputed、initWatch对给data中每个的属性进行递归深度劫持，定义各自的dep、及get、set方法，为依赖收集和数据触发视图更新做好准备。
       2. 其中数组的劫持主要是通过对7个改变数组的方法进行劫持，因此通过索引的方式操作数组无法影响视图的变化。
    2. 依赖收集
       1. 在数据首次渲染阶段，会触发属性的get方法，此时属性的dep会根据当前的Dep.target收集对应的多个watcher，如果data的属性值是对象或数组，会对对象和数组本身做依赖收集，方便实现对象的$set及数组的dep依赖收集。
       2. 如果get方法对应的value是数组，要对数组做递归处理，确保给每一个子数组都添加上dep依赖收集，这样才能保证操作数组里的子数组时，也触发到对应的watcher。
    3. 触发监听
       1. 建立了依赖收集后，当用户改变属性值时，就会触发属性的set方法，通过dep找到对应的watcher，执行渲染watcher、计算属性watcher、自定义watcher的回调，从而实现各自watcher的响应。
       2. 当同步改变多个属性值时，内部会在第一个属性值触发set时，通过nextTick异步调用watcher的更新操作，后续属性的set将不会触发异步更新，从而实现了属性异步更新的效果。