# 更新渲染，响应式原理
1. 首次渲染：在构建render方法时，会触发到每个属性的get方法。在get方法中给每个属性绑定dep和watcher。
    1. 在mountComponent时创建渲染Wather的实例。new Watcher实例时，会通过watcher的get>>getter>>updateComponent>>update(render)完成页面的渲染
    2. 给每个属性绑定dep及watcher：通过ast生成render方法时，会获取模板用到的data属性的get方法。在get时，会new一个Dep实例，调用dep.depend()，将dep添加到watcher的deps上。同时将watcher添加到dep的subs(watchers)中。dep和watcher实例都有自己的全局唯一id，在多对多绑定时，会保证唯一性。
    3. 在执行watcher里的get时，生成虚拟dom(执行update(render))前，会先在Dep.target上设置当前渲染watcher的实例，当页面渲染完毕后，再删除Dep.target上watcher。这样就锁定了render执行过程中，触发data的get时，dep所要绑定的watcher。

2. 更新渲染：当data属性的值发生变化时，会调用dep的notify方法，触发dep的渲染watcher进行页面渲染。
    1. 为了减少多个属性改变时，会导致页面多次渲染，在调用watcher更新时，会利用同步和异步的机制，让第一个赋值操作同步执行完后，异步执行watcher的get，这样可以先等赋值操作全部同步执行完后，异步执行watcher的get方法，get方法调用render重新渲染页面。(dep.notify => watcher.update => scheduler.queueWatcher => nextTick => wather.run => watcher.get)
    2. 异步更新：vue2中封装了自己的nextTick方法，nextTick内部缓存了nextTick的cb，通过timer异步清空nextTick中的cb。(这样用户和vue2内部都可以调用nextTick方法，当用户调用时，内部的已排在前面，这样可以确保用户调用nextTick时，页面已更新完毕)。
    3. vue2中timer的封装优先级：Promise => MutationObserver => setImmediate => setTimeout,vue3中只使用了promise

3. 响应式原理面试话术：
    响应式原理核心是通过definePrototype对data属性get和set方法的拦截，实现数据更新后自动渲染页面的目的。
    主要实现步骤分为以下三个步骤：
    1. 初始化(数据劫持)
       1. 在初始化initState时会通过initData、initComputed、initWatch完成对data的observer及相关watcher的收集。
       2. 在初始化initState时，会通过initData对data的每个属性进行深度递归的observer，为后面的每个属性收集不同的watcher做好准备。
          1. 其中数组的劫持主要是通过对7个改变数组的方法进行劫持，因此通过索引的方式操作数组无法影响视图的变化。
       3. 在initWatch时，通过自定义watcher的构造函数，获取watch中的key所对应的data的value，将此value作为oldValue。此时会触发data中针对该key的get方法，从而实现该key对于自定义watcher的收集。
       4. initComputed时，会将computed函数和vm通过defineProperty进行绑定。通过vm获取computed函数时，会触发computed函数。computed函数没有自己的dep。
    2. 首次渲染页面(依赖收集)
       1. 渲染watcher：首次渲染时，通过渲染watcher的构造函数触发exprOrFn => updateComponent，触发render函数时，会触发每个被observer的get方法，从而完成属性对渲染watcher的收集。
          1. 由于dep和watcher是多对多的关系，每个属性的dep可以装在多个不同类型的watcher。每个watcher会有自己的id，因此添加dep的watcher时可以通过id去重。同时一个渲染watcher也可以装载不同属性的dep，因此多个属性值发生变化时，触发一个渲染watcher即可。
          2. 如果get方法对应的value是数组，要对数组做递归处理，确保给每一个子数组都添加上dep依赖收集，这样保证了操作数组里的子数组时，也触发到对应的watcher。
       2. 计算watcher：当通过vm获取computed函数时，会触发computed函数内部的data属性收集data属性的计算watcher和渲染watcher。当data属性值发生改变时，会先执行计算watcher，然后执行渲染watcher。
    3. 更新数据(触发watcher)
       1. 当data发生变化时，通过data属性的set方法，触发渲染watcher => run => updateComponent => 实现页面的更新。
       2. 自定义watcher会通过run方法调用watcher内部的getter拿到最新的value，从而将最新的value和之前的oldvalue通过cb返回给用户。
    4. 异步更新
       1. 当同步改变多个属性值时，内部会在第一个属性值触发set时，通过nextTick异步调用watcher的更新操作，后续属性的set将不会触发异步更新，从而实现了属性异步更新的效果。

4. 响应式原理面试话术二次整理：
    响应式原理核心是通过definePrototype对data属性get和set方法的拦截，实现数据更新后自动渲染页面的目的。
    主要实现步骤分为以下三个步骤：
    1. 初始化(数据劫持)
       1. 在初始化initState时，会通过initData对data的每个属性进行深度递归的observer，为后面的每个属性收集不同的watcher做好准备。
          1. 其中数组的劫持主要是通过对7个改变数组的方法进行劫持，因此通过索引的方式操作数组无法影响视图的变化。
       2. 在initWatch时，通过自定义watcher的构造函数，获取watch中的key所对应的data的value，将此value作为oldValue。此时会触发data中针对该key的get方法，从而实现该key对于自定义watcher的收集。
       3. initComputed时，会将computed函数和vm通过单独的defineProperty进行绑定(因此computed函数没有自己的dep)。通过vm获取computed函数时，会触发computed函数。
    2. 首次渲染页面(依赖收集)
       1. 渲染watcher：首次渲染时，通过渲染watcher的构造函数触发exprOrFn => updateComponent，触发render函数时，会对模板中用到的data属性进行依赖收集，此时data属性的dep收集的是渲染watcher。
       2. 计算watcher：当通过vm获取computed函数时，会触发computed函数内部的data属性收集data属性的计算watcher和渲染watcher。同时将computed函数的计算watcher的dirty改为false，再次获取computed函数时，如果为false则不触发computed函数。
    3. 更新数据(触发watcher)
       1. 当data发生变化时，通过data属性的set方法，触发渲染watcher => update => exprOrFn => updateComponent => 实现页面的更新。
       2. 自定义watcher => update => get => 拿到watch的key对应的最新value，从而将最新的value和之前的oldvalue通过cb返回给用户。
       3. 计算watcher => update => 将dirty改为true => 渲染watcher => update => computed函数，如果dirty为true，将dirty改为false => 渲染computed函数的返回值 => 再次获取comouted函数返回值 => dirty为false => 直接返回计算watcher缓存的value。
    4. 异步更新
       1. 当同步改变多个属性值时，内部会在第一个属性值触发set时，通过nextTick异步调用watcher的更新操作，后续属性的set将不会触发异步更新，从而实现了属性异步更新的效果。