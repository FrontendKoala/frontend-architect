# 更新渲染，响应式原理
1. 首次渲染：在构建render方法时，会触发到每个属性的get方法。在get方法中给每个属性绑定dep和watcher。
    1. 在mountComponent时创建渲染Wather的实例。new Watcher实例时，会通过watcher的get>>getter>>updateComponent>>update(render)完成页面的渲染
    2. 给每个属性绑定dep及watcher：通过ast生成render方法时，会获取模板用到的data属性的get方法。在get时，会new一个Dep实例，调用dep.depend()，将dep添加到watcher的deps上。同时将watcher添加到dep的subs(watchers)中。dep和watcher实例都有自己的全局唯一id，在多对多绑定时，会保证唯一性。
    3. 在执行watcher里的get时，生成虚拟dom(执行update(render))前，会先在Dep.target上设置当前渲染watcher的实例，当页面渲染完毕后，再删除Dep.target上watcher。这样就锁定了render执行过程中，触发data的get时，dep所要绑定的watcher。

2. 更新渲染：当data属性的值发生变化时，会调用dep的notify方法，触发dep的渲染watcher进行页面渲染。
    1. 为了减少多个属性改变时，会导致页面多次渲染，在调用watcher更新时，会利用同步和异步的机制，让第一个赋值操作同步执行完后，异步执行watcher的get，这样可以先等赋值操作全部同步执行完后，异步执行watcher的get方法，get方法调用render重新渲染页面。(dep.notify => watcher.update => scheduler.queueWatcher => nextTick => wather.run => watcher.get)
    2. 异步更新：vue2中封装了自己的nextTick方法，nextTick内部缓存了nextTick的cb，通过timer异步清空nextTick中的cb。(这样用户和vue2内部都可以调用nextTick方法，当用户调用时，内部的已排在前面，这样可以确保用户调用nextTick时，页面已更新完毕)。
    3. vue2中timer的封装优先级：Promise => MutationObserver => setImmediate => setTimeout,vue3中只使用了promise