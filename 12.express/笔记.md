# 总结
1. express关于request的处理本质上是一种发布订阅模式
    1. get + pathName + cb 相当于是events.on, get + pathName 为name， cb为注册的函数
    2. 当来了请求后，根据method和pathName 在路由里找到对应的方法进行执行

2. express的实现思路
    0. application >> router >> layers(stack) >> route >> handlers(stack) >> next
    1. 创建application实例
        1. application实例挂载Router实例router，用于管理get、post等请求
        2. 挂载get、post等方法，用于存储到router的stack中
        3. 挂载listen方法，接收用户的request，将请求传递给router
    2. Layer类
        1. 用于分别构建Router里的layer实例和Route里的layer实例
        2. 存储了path和handler属性,router的layer.handler存储的是route的dispatch方法(用于遍历执行用户定义的回调)
    3. Router实例
        1. 挂载stack[]，用于存储get、post等方法对应的layer
        2. 挂载get、post等方法，用于处理app的get、post等方法
        3. 挂载route方法，用于生成layer和route，将layer存储到stack中，layer挂载了path和route的dispatch·
        4. 挂载hanlde方法，用于处理app.listen方法，根据request的pathname和method找到对应的路由layer
    4. Route实例
        1. 挂载了stack[]，用于存储自身的layer
        2. 批量挂载get post等方法，用于将用户定义的handlers存储到每个layer中
        3. 挂载dispatch方法，用于router的layer调用自己的handle_request
    5. 调用关系
        1. 方法订阅：app.get(path, handlers) >> router.get(path, handlers) >> route.get(hanlders) (其中router的layer存储path和route)

        2. emit方法：app.listen(port,...) >> router.layer.handle_request(req, res, done) >> route.dispatch(req, res, next) >> route.handlers (根据req的path和method，找到router中对应的layer，通过layer调用对应route的dispatch，dispatch中根据req的method执行对应的handlers)

        3. router.stack中的layer的handler是layer.route中的dispach
           route.stack中的layer的handler是用户订阅的handler